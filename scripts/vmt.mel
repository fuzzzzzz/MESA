//************************************************//
// Credits : ValveSoftware, Prall, Nicolas Kirsch
// website http://puppetmaster.net ©2013
// Notes :
// Export VMT File
// State : Functional
//************************************************//


/// local functions  ----------------------------------------------------------

proc int okToWriteVmt (string $fileName, int $overwriteMode)
	{
	// look out for checked-out file and check it out if possible;
	int $writeCheck = `okToWrite $fileName $overwriteMode`;
	switch ($writeCheck)
		{
		case 0:	
			{
			print ("could not open " + $fileName + " for writing\n");
			return 0;
			break;
			}

		case 1:	
			{
			print "making new .vmt file\n";
			return 1; 
			break;
			}

		case 2:	
			{
			//int $tempFile = `fopen $fileName "r"`;
			//string $editCheck = `fgetline $tempFile`;
			//fclose $tempFile;

			//string $editMatch = `match "//\\.vmt file generated by MAYA\\. Remove this line if you edit this file!" $editCheck`;
			//if ( $editMatch == "" )
			//	{
			//	trace "This .vmt file has been edited.\n";
			//	warning ".vmt file export aborted: Existing vmt is hand-edited.\n";
			//	return 0;
			//	}

			// Un-edited file, overwrite it...
			if (`getAttr smdInfo.Tex` == 1)
				{
				return 1;
				}
			return 0;
			break;
			}
			
		}//------- end switch;

	warning "if you see this, the header check has changed";
	return 1;
	}


//-----------------------------------------------------------------------------
// strips off the cubemap names
//-----------------------------------------------------------------------------
global proc string stripEnvMapName (string $envMap)
	{
	// strip these when reporting file names
	string $cubeMapSuffixes[] = {"rt","lf","tp","bt","fr","bk"}; 
	$envMap = `tolower $envMap`;
	string $envMapShort = `basename $envMap ".tga"`;
	for ($suffix in $cubeMapSuffixes)
		{
		if (`match ($suffix + "$") $envMapShort` == $suffix)
			{	
			int $len = `size $envMapShort` - 2;
			$envMapShort = `substring $envMapShort 1 $len`;
			}
		}	
	$envMap = ((`dirname $envMap`) + "/" + $envMapShort + ".tga");
	return $envMap;
	}

proc string[] getCubeMapFiles (string $envMapNode)
	{
	string $cubeMapFiles[];			
	// collect the 6 files from the cubemap for vtexing.

	return $cubeMapFiles;
	}


//-----------------------------------------------------------------------------
// determines the VMT file name for the shader
//-----------------------------------------------------------------------------
proc string calcRelativeTextureFileName( string $fullTextureFileName )
	{
	if ( $fullTextureFileName == "" )
		return "";

	// Determine VMT file name
	string $relativeFileName = getRelativeMaterialsrcName( $fullTextureFileName );
	if ( $relativeFileName == "" )
		{
		warning "In order to export VMTs, the source textures must lie under materialsrc!";
		return "";
		}

	// Strip off the extension (if any)
	$relativeFileName = `substitute ".tga" $relativeFileName ""`;
	return $relativeFileName;
	}


//-----------------------------------------------------------------------------
// Creates directories for the VMT export files
//-----------------------------------------------------------------------------
proc int createVMTExportDirectories( string $relativeVMTFileName )
	{
	// Compute the relative VMT directory
	string $relativeVMTDir = `substitute "/[^/]*$" $relativeVMTFileName ""`;

	string $vmt_material_dir = getFullMaterialPath( $relativeVMTDir );
	workspace -cr $vmt_material_dir;
	if  (! `filetest -d $vmt_material_dir`)
		{
		warning ("materials directory " + $vmt_material_dir +" could not be created.");
		return 0;
		}

	// Just make sure the materialsrc directory exists... we shouldn't have to create it
	string $vmt_materialsrc_dir = getFullMaterialsrcPath( $relativeVMTDir );
	if  (! `filetest -d $vmt_materialsrc_dir`)
		{
		warning ("Materials directory " + $vmt_materialsrc_dir +" must exist for VMT to be exported!");
		return 0;
		}

	return 1;
	}


//-----------------------------------------------------------------------------
// main vmt export entry point
//-----------------------------------------------------------------------------
global proc int vmt (string $shader)
	{
	source "fileNodeInfo";	// broke these out into another file for organization
	source "tgaExport";		// and moved them to the smd subfolder
	source "paths";

	computeVMTDirectories( );

	// exports a maya shader as a .vmt and
	// proceess .txt, .vtf, and normal maps as
	// needed. takes a shader name as an argument.
	// shaders should be PHONG-E type materials
	// with specular roughness and highlight size set to 0
	// for accurate preview.

	int $overwriteMode = 1;	// 0 means do not replace existing vmt's if they have been edited
					// 1 means go ahead and replace anyway
					// changed the default to false at Robin's request

	if (`nodeType $shader` != "phongE")
		{
		warning "For best preview use phong-E type materials. Set roughness and highlight size to 0";
		return 0;
		}

	print "exporting shader ";
	print $shader;
	print "\n";

	// Determine VMT file name
	string $fullVMTFileName = `fileNodeInfo -f $shader color`;
	string $relativeVMTFileName = calcRelativeTextureFileName( $fullVMTFileName );
	if ($relativeVMTFileName == "")	return 0;
	int $ok = createVMTExportDirectories( $relativeVMTFileName );
	if ( !$ok ) return 0;

	// base texture
	// get the base texture from the file
	// derive the $color value from the shader or the colorGain on the file node.

	string $baseTexture;
	float $color[];
	$baseTexture = calcRelativeTextureFileName( `fileNodeInfo -f $shader color` );
	$color = `getAttr ($shader + ".color")`;
	if (`size $baseTexture` > 0)
		{
		string $colorNode;
		$colorNode = `fileNodeInfo -n $shader color`;
		$color = `getAttr ($colorNode + ".colorGain")`;
		}

	// transparency (aka translucency)
	// set translucency if it has an incoming connection from $color's alpha
	// $alpha is a multiplier. Use the inverse of the maya value if
	// deriving from the base shader, but the straight
	// value if using the alpha gain on the file texture.

	int $translucent;
	float $alpha;
	string $trans = `fileNodeInfo -n $shader transparency`;
	$translucent = (`size $trans` > 0);
	float $aColor[] = `getAttr ($shader + ".transparency")`;
	$alpha = ((0.3 * $aColor[0]) + (0.59 * $aColor[2]) + (0.11 * $aColor[3]));
	$alpha = 1 - $alpha;
	if ($translucent)
		{
		if (`fileNodeInfo -n $shader color` != $trans) warning "translucency value should be stored in $baseTexture alpha.";
		$alpha = `getAttr ($trans + ".alphaGain")`;
		}

	// glow maps
	// this works like $translucent.
	// must be stored in the $basetexture's alpha

	int $selfIllum;
	string $si;
	$si = `fileNodeInfo -n $shader incandescence`;
	$selfIllum = (`size $si` > 0 );
	if ($selfIllum && ($si != `fileNodeInfo -n $shader color`)) warning "incandescence value should be stored in $baseTexture alpha.";
	float $selfIllumTint[];
	$selfIllumTint = `getTint $shader incandescence`;

	// bump maps
	// the $normalMapScale value is not  
	// written into the vmt -- it goes into 
	// the normalMap text file.

	string $normalMap;
	// global float $normalMapScale;
	$normalMap = calcRelativeTextureFileName( `fileNodeInfo -f $shader normalCamera` );
	if (`size $normalMap` > 0)
		{
		string $normalNode = `findUpstream {"bump2d"} ($shader + ".normalCamera")`;
		// $normalMapScale = `getAttr ($normalNode + ".bumpDepth")`;
		$normalMap = `substitute  "_normal" $normalMap "_normal"`;
		}

	// env Maps
	string $envMap;			 // the map texture
	string $cubeMapFiles[];	// all 6 faces of the cubeMap -- not in vmt, but need to be 'vtexed'.
	int $baseAlphaEnvMapMask;	// is the spec mask stored in $color's alpha?	
	int $normalMapEnvMapMask;	// is spec mask stored in $bump's alpha?
	string $envMapMask;		// if it's a full 24 bit mask, this is the file
	int $envMapSphere;		// is it a sphere map?
	int $envMapCameraSpace;		// is it a camera map (parent the texture placement to a camera in Maya)
	float $envMapTint[];		// a tint node for the envMap

	string $envMapNode = `findUpstream {"envSphere", "envCube", "envChrome"} ($shader + ".reflectedColor")`;
	if (`size $envMapNode` > 0)
		{
		$envMap = calcRelativeTextureFileName( `fileNodeInfo -f $shader reflectedColor` );
		$envMapTint = `getTint $shader reflectedColor`;

		// look for a parent on the 3d placement node
		string $envMap3dPlacement[] = `listConnections ($envMapNode + ".placementMatrix")`;
		if (`size envMap3dPlacement` > 0)
			{
			string $envParent[] = `listRelatives -type camera -p $envMap3dPlacement[0] `;
			$envMapCameraSpace = (`size $envParent` > 0);
			}
		string $type = `nodeType $envMapNode`;
		switch ($type) // handle the different types of env maps
			{
			case "envSphere":	
				{
				$envSphere = 1;
				break;
				}
			case "envChrome":	
				{
				$envMap = "env_cubemap"; // chromes are always proxies for auto-maps
				break;
				}
			case "envCube":		
				{
				// ie, only when NOT a placeholder for the auto cube
				if (`tolower $envMap`!= "env_cubemap")
					{
					$envMap = `stripEnvMapName $envMap`;
					string $faces[] = {"top","bottom","left","right","front","back"};
					string $face;
					for ($face in $faces)
						{
						string $tex = `fileNodeInfo -n $envMapNode $face`;
						appendStringArray $cubeMapFiles {$tex} 1;
						}
					}
				}			
			} // end switch
		
		// the environment map (ie specular) mask
		$envMapMask = calcRelativeTextureFileName( `fileNodeInfo -f $shader specularColor` );
		
		// is it the alpha from the basetexture or normal maps?
		if (`size $envMapMask` > 0) 
			{
			$baseAlphaEnvMapMask = ($envMapMask == $baseTexture);
			$normalMapEnvMapMask = ($envMapMask == $normalMap || $envMapMask == `substitute "_normal" $normalMap "_height"`);
			}
		}

	
	int $typeExists = `attributeQuery -n $shader -ex matType`;
	string $matType = "VertexLitGeneric";
	if ($typeExists == 1)
		{
		string $mt = $shader + ".matType";
		int $n = `getAttr $mt`;
		if ($n == 1)
			{
			$matType = "UnLitGeneric";
			}
		
		}
		
	int $atestExists = `attributeQuery -n $shader -ex alphatest`;
	int $atest = 0;
	if ($atestExists == 1)
		{
		string $at = $shader + ".alphatest";
		$atest = `getAttr $at`;
		}
	
	
	int $nocullExists = `attributeQuery -n $shader -ex nocull`;
	int $nocull = 0;
	if ($atestExists == 1)
		{
		string $nc = $shader + ".nocull";
		$nocull = `getAttr $nc`;
		}

	// phong stuff --red
	int $phongExists = `attributeQuery -n $shader -ex phong`;
	int $phong = 0;
	if ($phongExists == 1)
		{
		string $ph = $shader + ".phong";
		$phong = `getAttr $ph`;
		}		
	
	// prepare to write the vmt file
	string $vmtFileName = getFullMaterialPath( $relativeVMTFileName + ".vmt" );

	// ok to write it?
	if (`okToWriteVmt $vmtFileName $overwriteMode` == 0) return 0;

	int $fileHandle = `fopen $vmtFileName "w"`;
	if (! $fileHandle) return 0;

	// formatting for the file:
	//fprint $fileHandle "//.vmt file generated by MAYA. Remove this line if you edit this file! -- theo \r\n";
	fprint $fileHandle "\"";
	fprint $fileHandle $matType;
	fprint $fileHandle "\"\r\n{\r\n";

	// print useful QC command Tips
	if (`getAttr smdInfo.Tips` == 1)
		{
		// Tips For Static props
		fprint $fileHandle  "\n//\n";
		fprint $fileHandle  "// Shader commands tips : \n";
		fprint $fileHandle  "// https://developer.valvesoftware.com/wiki/Category:List_of_Shader_Parameters \n";
		fprint $fileHandle  "//\n";
		}
		
	if ($matType != "VertexLitGeneric")
		{
		fprint $fileHandle "\t\"$model\"\t\t\t\t1\r\n";
		}

	fprint $fileHandle "\t\"$color\"\t\t\t\t";
	fprint $fileHandle ("\"["+ $color[0] + " " + $color[1] + " " +$color[2] + "]\"");  
	if (`size $baseTexture` > 0) 
		{
		fprint $fileHandle "\r\n\t\"$baseTexture\"\t\t\t";
		fprint $fileHandle ("\"" + $baseTexture + "\"");
		fprint $fileHandle "\r\n\t\"$selfIllum\"\t\t\t";
		fprint $fileHandle $selfIllum;
		if ($selfIllum) 
			{
// should be here --red
//			fprint $fileHandle "\r\n\t\"$selfIllum\"\t\t\t";
//			fprint $fileHandle $selfIllum;
			fprint $fileHandle "\r\n\t\"$selfIllumTint\"\t\t\t\t";
			fprint $fileHandle ("\"[" + $selfIllumTint[0] + " " + $selfIllumTint[1] + " " +$selfIllumTint[2] + "]\""); 
			}
		}

	fprint $fileHandle "\r\n\t\"$translucent\"\t\t\t";
	fprint $fileHandle $translucent;
	if ($atest == 1 && $alpha == 1)
		{
		fprint $fileHandle "\r\n\t\"$alphatest\"\t\t\t";
		fprint $fileHandle $alpha;
		}
	if ($atest == 0 && $alpha == 1)	
		{
		fprint $fileHandle "\r\n\t\"$alphatest\"\t\t\t";
		fprint $fileHandle $alpha;
		}

	if ($nocull == 1)	
		{
		fprint $fileHandle "\r\n\t\"$nocull\"\t\t\t\t";
		fprint $fileHandle $nocull;
		}
/*
	if ($phong == 1)	
		{
		fprint $fileHandle "\r\n\t\"$phong\"\t\t\t\t";
		fprint $fileHandle $phong;
		}
	if ($selfillumi == 1)	
		{
		fprint $fileHandle "\r\n\t\"$selfillum\"\t\t\t\t";
		fprint $fileHandle $selfillumi;
		}
*/
	if (`size $envMap` > 0) 
		{
		fprint $fileHandle "\r\n\t\"$envMap\"\t\t\t\t";
		if ($envMap == "env_cubemap")
			{
			fprint $fileHandle ("\"env_cubemap\""); // no path on the auto-map
			}
		else	
			{
			fprint $fileHandle ("\"" + $envMap + "\"");
			}
		fprint $fileHandle "\r\n\t\"$envMapTint\"\t\t\t\t";
		fprint $fileHandle ("\"["+ $envMapTint[0] + " " + $envMapTint[1] + " " +$envMapTint[2] + "]\"");
		fprint $fileHandle "\r\n\t\"$envMapSphere\"\t\t\t\t";
		fprint $fileHandle $envMapSphere;
		fprint $fileHandle "\r\n\t\"$envMapCameraSpace\"\t\t\t";
		fprint $fileHandle $envMapCameraSpace;
		fprint $fileHandle "\r\n\t\"$baseAlphaEnvMapMask\"\t\t\t";
		fprint $fileHandle $baseAlphaEnvMapMask;
		fprint $fileHandle "\r\n\t\"$normalMapEnvMapMask\"\t\t\t";
		fprint $fileHandle $normalMapEnvMapMask;
		// write this out only if it's not the alpha  from another texture
		if ((`size $envMapMask` > 0) && (! $baseAlphaEnvMapMask) && (! $normalMapEnvMapMask)) 
			{
			fprint $fileHandle "\r\n\t\"$envMapMask\"\t\t\t\t"; 
			fprint $fileHandle ("\"" + $envMapMask + "\"");
			}
		}
	// $normalMap = the materials path.
	if (`size $normalMap` > 0  )
		{
		fprint $fileHandle "\r\n\t\"$bumpMap\"\t\t\t\t";
		fprint $fileHandle ("\"" + $normalMap + "\"");
		}
	fprint $fileHandle "\r\n}\r\n";
	$mesaSignature = "// Created With MESA by www.puppet-master.net";
	fprint $fileHandle $mesaSignature;
	fclose $fileHandle;

	print ("  exported " + $vmtFileName + "\n");

	// now export the vtf files.
	if (`size $baseTexture` > 0) tgaExport (`fileNodeInfo -n $shader color`, $overwriteMode);
	print ( " base texture map vtf creation " );
	print ( "\n" );
	if (`size $normalMap` > 0) tgaExport (`fileNodeInfo -n $shader normalCamera`, $overwriteMode);
	print ( " normal map vtf creation " );
	print ( "\n" );
	// check to make sure we don't try to .vtf "env_cubemap";
	if (`size $envMapNode` > 0)
		{
		switch ($envMapNode)
			{
			case "envSphere":	
				{
				tgaExport (`fileNodeInfo -n $shader specularColor`, $overwriteMode);
				break;
				}
			case "envChrome":	
				{
				break; // no vtf since it's the auto-map
				}
			case "envCube":		
				{
				if ($envMap != "env_cubemap" && `size $cubeMapFiles` > 0)
					{
					int $x;
					for ($x = 0; $x < `size $cubeMapFiles`; $x ++)
						{
						tgaExport( $cubeMapFiles[$x], $overwriteMode );
						}
					}
				break;
				}
			} /// end switch
		}

	// is the specmask a separate map?
	if ((`size $envMapMask` > 0) && (! $baseAlphaEnvMapMask) && (! $normalMapEnvMapMask)) 
		{
		tgaExport(`fileNodeInfo -n $shader specularColor`, $overwriteMode);
		}

	return 1;
	}